############################################################################################################
## SDMs considering spatial autocorrelation
############################################################################################################

### Autocovariate regression
# The validity of this approach strongly hinges on the correct choice of the neighbourhood scheme!
#   Using 'style="B"' ensures symmetry of the neighbourhood matrix (i.e. w_nm = w_mn). Please
#   see Bardos et al. (2015) for details.

library(spdep)

autocov_dist(z, xy, nbs = 1, type = "inverse", zero.policy = NULL,
             style = "B", longlat=NULL)

if (require(rgdal, quietly=TRUE)) {
  example(columbus, package="spData")
  
  xy <- cbind(columbus$X, columbus$Y)
  # Weighting scheme = equal
  ac1a <- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
                       type="one")
  # Weighting scheme = inverse distance
  acinva <- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
                         type="inverse")
  # Weighting scheme = (inverse distance)^2
  acinv2a <- autocov_dist(columbus$CRIME, xy, nbs=10, style="B",
                          type="inverse.squared")
  
  
  plot(ac1a ~ columbus$CRIME, pch=16, asp=1)
  points(acinva ~ columbus$CRIME, pch=16, col="red")
  points(acinv2a ~ columbus$CRIME, pch=16, col="blue")
  abline(0,1)
  
  ### Compare autocovariate values and actual values
  # neighbourhood structure by distance
  nb <- dnearneigh(xy, 0, 10)
  # Convert the above to list objest with weighting
  lw <- nb2listw(nb, style="B")
  # multiply actual values by the neighbourhood distance
  ac1b <- lag(lw, columbus$CRIME)
  all.equal(ac1b, ac1a)
  
  # measure distance between neighbourhood cells
  nbd <- nbdists(nb, xy)
  # Invert the distances
  gl <- lapply(nbd, function(x) 1/x)
  lw <- nb2listw(nb, glist=gl) # glist = list of general weights corresponding to neighbours
  acinvb <- lag(lw, columbus$CRIME)
  all.equal(acinvb, acinva)
  
  gl2 <- lapply(nbd, function(x) 1/(x^2))
  lw <- nb2listw(nb, glist=gl2)
  acinv2b <- lag(lw, columbus$CRIME)
  all.equal(acinv2b, acinv2a)
  
  ### GLM
  summary(glm(CRIME ~ HOVAL + ac1b, data=columbus, family="gaussian"))
  summary(glm(CRIME ~ HOVAL, data=columbus, family="gaussian"))
  ### SAR with another neighbourhood scheme from "B"
  summary(
    spautolm(columbus$CRIME ~ HOVAL, data=columbus,
           listw=nb2listw(nb, style="W"))
  )

}

### Genaralised estimation equation
library(gee)

data(warpbreaks)
## marginal analysis of random effects model for wool (what's difference from GLMM?)
summary(gee(breaks ~ tension, id=wool, data=warpbreaks, corstr="exchangeable", family = poisson))

### Comparison
library(glmmML)
summary(glmmML(breaks ~ tension, cluster = wool, data = warpbreaks, family = poisson))

## test for serial correlation in blocks
summary(gee(breaks ~ tension, id=wool, data=warpbreaks, corstr="AR-M", Mv=1))
if(require(MASS)) {
  data(OME)
  ## not fully appropriate link for these data.
  (fm <- gee(cbind(Correct, Trials-Correct) ~ Loud + Age + OME, id = ID,
             data = OME, family = binomial, corstr = "exchangeable"))
  summary(fm)
}



### blockCV (http://htmlpreview.github.io/?https://github.com/rvalavi/blockCV/blob/master/vignettes/BlockCV_for_SDM.html)
library(raster)
library(blockCV)

awt <- raster::brick(system.file("extdata", "awt.grd", package = "blockCV"))
sac.test <- spatialAutoRange(rasterLayer = awt, # raster file
                 sampleNumber = 5000, # number of cells to be used
                 doParallel = TRUE,
                 showPlots = TRUE)

# import presence-absence species data
PA <- read.csv(system.file("extdata", "PA.csv", package = "blockCV"))
# make a SpatialPointsDataFrame object from data.frame
pa_data <- SpatialPointsDataFrame(PA[,c("x", "y")], PA, proj4string=crs(awt))

plot(awt[[1]]) # plot raster data
points(pa_data[which(pa_data$Species==1), ], col="red") # add presence points
points(pa_data[which(pa_data$Species==0), ], col="blue") # add absence points
legend(x=500000, y=8250000, legend=c("Presence","Absence"), col=c(2, 4), pch=c(1,1), bty="n")


# spatial blocking by specified range with random assignment
sb <- spatialBlock(speciesData = pa_data,
                   species = "Species",
                   rasterLayer = awt,
                   theRange = 68000, # size of the blocks
                   k = 5,
                   selection = "random",
                   iteration = 250, # find evenly dispersed folds
                   biomod2Format = TRUE,
                   xOffset = 0, # shift the blocks horizontally
                   yOffset = 0)


# adding points on saptialBlock plot
sb$plots + geom_point(data = as.data.frame(coordinates(pa_data)), aes(x=x, y=y), alpha=0.6)

##################################################################################
# Use blockCV in biomod2
##################################################################################

library(biomod2)
# species occurrences
DataSpecies <- read.csv(system.file("extdata", "PA.csv", package = "blockCV"))
# the name of studied species
myRespName <- "Species"
# the presence/absences data for our species
myResp <- as.numeric(DataSpecies[,myRespName])
# the XY coordinates of species data
myRespXY <- DataSpecies[,c("x","y")]
# change the RasterBrick to RasterStack
awt <- stack(awt)

# 1. Formatting Data
myBiomodData <- BIOMOD_FormatingData(resp.var = myResp,
                                     expl.var = awt, # explanatory raster data
                                     resp.xy = myRespXY,
                                     resp.name = myRespName,
                                     na.rm = TRUE)

# 2. Defining the folds for DataSplitTable
# note that biomodTable should be used here not folds
DataSplitTable <- sb$biomodTable # use generated folds from spatialBlock in previous section

# 3. Defining Models Options using default options.
myBiomodOption <- BIOMOD_ModelingOptions()

# # 4. Model fitting
# myBiomodModelOut <- BIOMOD_Modeling( myBiomodData,
#                                      models = c('GLM','MARS','GBM'),
#                                      models.options = myBiomodOption,
#                                      DataSplitTable = DataSplitTable, # blocking folds
#                                      VarImport = 0,
#                                      models.eval.meth = c('ROC'),
#                                      do.full.models=FALSE,
#                                      modeling.id="test")
# 4. Model fitting
myBiomodModelOut.block <- BIOMOD_Modeling( myBiomodData,
                                           models = c('GLM','MARS','GBM'),
                                           models.options = myBiomodOption,
                                           DataSplitTable = DataSplitTable, # blocking folds
                                           VarImport = 100,
                                           models.eval.meth = c('ROC', 'TSS'),
                                           do.full.models=FALSE,
                                           modeling.id="test")
# 5. Model evaluation
# get all models evaluation
myBiomodModelEval <- get_evaluations(myBiomodModelOut.block)
myBiomodModelEval["ROC","Testing.data",,,]


### Variable importance
myBiomodModelOut.block@variables.importances@val

